# build-multiarch-image-template.yml
.build-multiarch-image-template:
  variables:
    GIT_DEPTH: 1
    HARBOR_REGISTRY: oci.saicds.com
    # DOCKERFILE_PATH: ""  # To be overridden
    # IMAGE_NAME: ""       # To be overridden
    # IMAGE_VERSION: ""    # To be overridden
    # HARBOR_PROJECT: ""   # To be overridden
    # TARGET: ""           # To be overridden


stages:
  - build
  - packaging

# Build for linux/amd64
.build-amd64:
  extends: .build-multiarch-image-template
  stage: build
  image: docker:dind
  tags:
    - self-hosted-amd64
  variables:
    PLATFORMS: linux/amd64
  before_script:
    - echo "DOCKERFILE_PATH is $DOCKERFILE_PATH"
    - echo "IMAGE_NAME is $IMAGE_NAME"
    - echo "HARBOR_REGISTRY is $HARBOR_REGISTRY"
    - echo "PLATFORMS is $PLATFORMS"
    - echo "TARGET is $TARGET"
    - echo "IMAGE_VERSION is $IMAGE_VERSION"
    - mkdir -p scripts
    - |
      cat > scripts/docker-login.sh << 'EOF'
      #!/usr/bin/env sh

      # Check if .env exists and source it
      if [ -f .env ]; then
          echo "Sourcing from .env file"
          source .env
      else
          echo "Error: .env file not found!"
          exit 1
      fi

      # Exit if docker login fails
      echo "$HARBOR_TOKEN" | docker login -u "${HARBOR_USERNAME}" --password-stdin "$HARBOR_REGISTRY" || exit 1
      EOF
    - chmod +x scripts/docker-login.sh
    - echo "HARBOR_USERNAME=$HARBOR_USERNAME" > scripts/.env
    - echo "HARBOR_TOKEN=$HARBOR_TOKEN" >> scripts/.env
    - echo "HARBOR_REGISTRY=$HARBOR_REGISTRY" >> scripts/.env
    - docker --version
    - chmod +x scripts/docker-login.sh
    - cd scripts
    - sh docker-login.sh
    - cd ../
  script:
    - FULL_IMAGE_NAME="$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_VERSION-amd64"
    - echo "Building $FULL_IMAGE_NAME"
    - |
      if [ -n "$TARGET" ]; then
        echo "Using target: $TARGET"
        docker build -f $DOCKERFILE_PATH --target $TARGET -t "$FULL_IMAGE_NAME" --push .
      else
        echo "No target specified, building default"
        docker build -f $DOCKERFILE_PATH -t "$FULL_IMAGE_NAME" --push .
      fi
    - docker images
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'  # Manual trigger
      when: manual
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'  # Push to main
      when: manual
    - changes:
        - $DOCKERFILE_PATH
      when: always
  after_script:
    - docker logout

# Build for linux/arm64
.build-arm64:
  extends: .build-multiarch-image-template
  stage: build
  image: docker:dind
  tags:
    - self-hosted-arm64
  variables:
    PLATFORMS: linux/arm64
  before_script:
    - echo "DOCKERFILE_PATH is $DOCKERFILE_PATH"
    - echo "IMAGE_NAME is $IMAGE_NAME"
    - echo "HARBOR_REGISTRY is $HARBOR_REGISTRY"
    - echo "PLATFORMS is $PLATFORMS"
    - echo "TARGET is $TARGET"
    - echo "IMAGE_VERSION is $IMAGE_VERSION"
    - mkdir -p scripts
    - |
      cat > scripts/docker-login.sh << 'EOF'
      #!/usr/bin/env sh

      # Check if .env exists and source it
      if [ -f .env ]; then
          echo "Sourcing from .env file"
          source .env
      else
          echo "Error: .env file not found!"
          exit 1
      fi

      # Exit if docker login fails
      echo "$HARBOR_TOKEN" | docker login -u "${HARBOR_USERNAME}" --password-stdin "$HARBOR_REGISTRY" || exit 1
      EOF
    - chmod +x scripts/docker-login.sh
    - echo "HARBOR_USERNAME=$HARBOR_USERNAME" > scripts/.env
    - echo "HARBOR_TOKEN=$HARBOR_TOKEN" >> scripts/.env
    - echo "HARBOR_REGISTRY=$HARBOR_REGISTRY" >> scripts/.env
    - docker --version
    - chmod +x scripts/docker-login.sh
    - cd scripts
    - sh docker-login.sh
    - cd ../
  script:
    - FULL_IMAGE_NAME="$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_VERSION-arm64"
    - echo "Building $FULL_IMAGE_NAME"
    - |
      if [ -n "$TARGET" ]; then
        echo "Using target: $TARGET"
        docker build -f $DOCKERFILE_PATH --target $TARGET -t "$FULL_IMAGE_NAME" --push .
      else
        echo "No target specified, building default"
        docker build -f $DOCKERFILE_PATH -t "$FULL_IMAGE_NAME" --push .
      fi
    - docker images
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'  # Manual trigger
      when: manual
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'  # Push to main
      when: manual
    - changes:
        - $DOCKERFILE_PATH
      when: always
  after_script:
    - docker logout

# Create and push manifest
.create-manifest:
  extends: .build-multiarch-image-template
  stage: packaging
  image: docker:dind
  tags:
    - self-hosted-amd64
  before_script:
    - echo "IMAGE_VERSION is $IMAGE_VERSION"
    - mkdir -p scripts
    - |
      cat > scripts/docker-login.sh << 'EOF'
      #!/usr/bin/env sh

      # Check if .env exists and source it
      if [ -f .env ]; then
          echo "Sourcing from .env file"
          source .env
      else
          echo "Error: .env file not found!"
          exit 1
      fi

      # Exit if docker login fails
      echo "$HARBOR_TOKEN" | docker login -u "${HARBOR_USERNAME}" --password-stdin "$HARBOR_REGISTRY" || exit 1
      EOF
    - chmod +x scripts/docker-login.sh
    - echo "HARBOR_USERNAME=$HARBOR_USERNAME" > scripts/.env
    - echo "HARBOR_TOKEN=$HARBOR_TOKEN" >> scripts/.env
    - echo "HARBOR_REGISTRY=$HARBOR_REGISTRY" >> scripts/.env
    - docker --version
    - chmod +x scripts/docker-login.sh
    - cd scripts
    - sh docker-login.sh
    - cd ../
  script:
    - FINAL_IMAGE="$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_VERSION"
    - AMD64_IMAGE="$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_VERSION-amd64"
    - ARM64_IMAGE="$HARBOR_REGISTRY/$HARBOR_PROJECT/$IMAGE_NAME:$IMAGE_VERSION-arm64"
    - echo "Creating manifest for $FINAL_IMAGE"

    # Check which images exist and build the manifest command
    - IMAGES=""
    - |
      if docker manifest inspect "$AMD64_IMAGE" > /dev/null 2>&1; then
        echo "✓ AMD64 image found: $AMD64_IMAGE"
        IMAGES="$IMAGES --amend $AMD64_IMAGE"
      else
        echo "✗ AMD64 image not found: $AMD64_IMAGE"
      fi
    - |
      if docker manifest inspect "$ARM64_IMAGE" > /dev/null 2>&1; then
        echo "✓ ARM64 image found: $ARM64_IMAGE"
        IMAGES="$IMAGES --amend $ARM64_IMAGE"
      else
        echo "✗ ARM64 image not found: $ARM64_IMAGE"
      fi

    # Create manifest only if at least one image exists
    - |
      if [ -z "$IMAGES" ]; then
        echo "ERROR: No platform images found!"
        exit 1
      fi
    - echo "Creating manifest with:$IMAGES"
    - docker manifest create "$FINAL_IMAGE" $IMAGES
    - docker manifest push "$FINAL_IMAGE"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'  # Manual trigger
      when: manual
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'  # Push to main
      when: manual
    - changes:
        - $DOCKERFILE_PATH
      when: always
  after_script:
    - docker logouts
